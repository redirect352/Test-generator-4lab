using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis.CSharp;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestGeneratorLib.FileInformation;

namespace TestGeneratorLib
{
    public class TestGenerator
    {
        private static readonly  SourceCodeAnalyzer codeAnalyzer = new SourceCodeAnalyzer();

        private static readonly AttributeSyntax TestClassAtribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("TestFixture"));
        private static readonly AttributeSyntax TestMethodAtribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("Test"));


        public Dictionary<string, string> GenerateTests(string fileContent)
        {
            var result = new Dictionary<string, string>();
            FileDescription fileDescription = codeAnalyzer.GetDescription(fileContent);
            foreach (var classInfo in fileDescription.Classes)
            {
                var classDeclaration = this.GenerateClassDeclaration(classInfo);
                var compilationUnit = SyntaxFactory.CompilationUnit()
                   .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                   .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("NUnit.Framework")))
                   .AddMembers(classDeclaration);
                result.Add(classInfo.ClassName, compilationUnit.NormalizeWhitespace().ToFullString());

            }
            return result;

        }


        private ClassDeclarationSyntax GenerateClassDeclaration(ClassDescription classDescription)
        {
            var methods = new List<MethodDeclarationSyntax>();
            foreach (var methodInfo in classDescription.Methods)
            {
                methods.Add(GenerateMethodDeclaration(methodInfo));
            }


            var attributes = SyntaxFactory.AttributeList().Attributes.Add(TestClassAtribute);
            var list = SyntaxFactory.AttributeList(attributes);
            var classDeclaration = SyntaxFactory.ClassDeclaration(classDescription.ClassName).AddAttributeLists(list).AddMembers(methods.ToArray());

            return classDeclaration;
        }



        private MethodDeclarationSyntax GenerateMethodDeclaration( MethodDescription methodDescription)
        {
            List<StatementSyntax> failTest = new List<StatementSyntax>();

            var failExpression =  SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(SyntaxFactory.MemberAccessExpression(
                                  SyntaxKind.SimpleMemberAccessExpression,SyntaxFactory.IdentifierName("Assert"), SyntaxFactory.IdentifierName("Fail"))).WithArgumentList(
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                                SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression,SyntaxFactory.Literal("Autogenerated")))))));

            failTest.Add(failExpression);
            var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), methodDescription.Name)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(TestMethodAtribute)))
                .WithBody(SyntaxFactory.Block(failExpression));
            return method;
        }

    }
}
