using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestGeneratorLib.FileInformation;




namespace TestGeneratorLib
{
    class TestMethodsGenerator
    {

        internal MethodDeclarationSyntax GenerateSetupMethod( string @class,MethodDescription mainConstructor)
        {
            List<StatementSyntax> failTest = new List<StatementSyntax>();
            string params1 = "";
            if (mainConstructor != null)
            {
                foreach (string param in mainConstructor.Parameters.Keys)
                {
                    if (mainConstructor.Parameters[param].First() != 'I')
                    {
                        failTest.Add(SyntaxFactory.ParseStatement(string.Format("{0} {1} = default({2});", mainConstructor.Parameters[param], param, mainConstructor.Parameters[param])));

                        params1 += param + ",";
                    }
                    else
                    {
                        string name = TestGenerator.GetDependencyName(mainConstructor.Parameters[param]);
                        failTest.Add(SyntaxFactory.ParseStatement(string.Format("{0} = new {1}();", name, $"Mock<{mainConstructor.Parameters[param]}>")));
                        params1 += name + ".Object,";

                    }

                }
                if (params1 != "")
                {
                    params1 =  params1.Remove(params1.Length-1);
                }
                
            }

            failTest.Add(SyntaxFactory.ParseStatement(string.Format("{0} = new {1}({2});", TestGenerator.GetClassVarName(@class), @class,params1)));



            return SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), "SetUp")
               .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
               .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(SyntaxFactory.Attribute(SyntaxFactory.ParseName("SetUp")))))
               .WithBody(SyntaxFactory.Block(failTest));
        }



        internal MethodDeclarationSyntax GenerateMethodDeclaration(MethodDescription methodDescription, AttributeSyntax TestMethodAttribute, string ClassVariableName)
        {
            List<StatementSyntax> failTest = new List<StatementSyntax>();

            failTest.AddRange(GenerateArrangePart(methodDescription.Parameters));
            var failExpression = SyntaxFactory.ExpressionStatement(SyntaxFactory.InvocationExpression(SyntaxFactory.MemberAccessExpression(
                                  SyntaxKind.SimpleMemberAccessExpression, SyntaxFactory.IdentifierName("Assert"), SyntaxFactory.IdentifierName("Fail"))).WithArgumentList(
                        SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                                SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal("Autogenerated")))))));
            failTest.Add(GenerateActPart(methodDescription, ClassVariableName));

            if (methodDescription.ReturnType != "void")
            {
                failTest.AddRange(GenerateAssertPart(methodDescription));

            }
            

            failTest.Add(failExpression);
            var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), methodDescription.Name)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(TestMethodAttribute)))
                .WithBody(SyntaxFactory.Block(failTest));
            return method;
        }

        private List<StatementSyntax> GenerateArrangePart(Dictionary<string, string> parameters)
        {
            List<StatementSyntax> result = new List<StatementSyntax>();
            foreach (string param in parameters.Keys)
            {
                if (parameters[param].First() != 'I')
                {
                     result.Add(SyntaxFactory.ParseStatement(string.Format("{0} {1} = default({2});" ,parameters[param], param,parameters[param] )));
                }
            }
            return result;

        }


        private StatementSyntax GenerateActPart(MethodDescription description,string classVar)
        {
            StatementSyntax result;
            string params1 = "";
            foreach (string p in description.Parameters.Keys)
            {
                if (params1 != "")
                {
                    params1 += ",";
                }
                if (description.Parameters[p].First() != 'I')
                {
                    params1 += p;
                }
                else
                {
                    params1 += TestGenerator.GetDependencyName(description.Parameters[p]);
                }
            
            }

            if (description.ReturnType != "void")
            {
                result = SyntaxFactory.ParseStatement(string.Format("{0} actual = {1}.{2}({3});", description.ReturnType, classVar, description.Name, params1));
            }
            else
            {
                result = SyntaxFactory.ParseStatement(string.Format("{1}.{2}({3});", description.ReturnType, classVar, description.Name, params1));
            
            }

            return result;

        }

        private List<StatementSyntax> GenerateAssertPart(MethodDescription description)
        {
            List<StatementSyntax> result = new List<StatementSyntax>();

            result.Add(SyntaxFactory.ParseStatement(string.Format("{0} expected = default({0});",description.ReturnType)));
            result.Add(SyntaxFactory.ParseStatement(string.Format("Assert.That(actual, Is.EqualTo(expected));")));

        
            return result;
        }


        internal static MethodDescription GetMainConstructor(List<MethodDescription> methods)
        {
            MethodDescription mainConstructor = null;

            foreach (MethodDescription methodDescription in methods.Where((MethodDescription m) => (m.IsConstructor)))
            {
                if (mainConstructor == null)
                {
                    mainConstructor = methodDescription;
                }
                else if (mainConstructor.Parameters.Count < methodDescription.Parameters.Count)
                {
                    mainConstructor = methodDescription;
                }

            }
            return mainConstructor;
        }

    }
}
